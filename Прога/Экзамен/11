//с двумя параметрами 
template<class TYPE1, class TYPE2>
void swap(TYPE1& x, TYPE2& y)
{
    TYPE1 temp;
    temp = x;
    x = y;
    y = temp;
}

int main()
{
    double x = 1;
    int y = 3;
    swap(x,y);
}
//c пользовательских типом
class complex
{
    double x, y;
public:
    complex()
    {
        x = 0;
        y = 0;
    }
    complex(double a, double b)
    {
        x = a;
        y = b;
    }
};
template<class TYPE1, class TYPE2>
void swap(TYPE1& x, TYPE2& y)
{
    TYPE1 temp;
    temp = x;
    x = y;
    y = temp;
}
int main()
{
    complex x;
    complex y(4,3);
    swap(x,y);
}

 Параметрический полиморфизм позволяет многократно использовать один и тот же код применительно к разным типам данных – тип указывается как параметр функции или класса.
При создании функций иногда возникают ситуации, когда две функции выполняют одинаковую обработку, но работают с разными типами данных. С помощью механизма перегрузки функций можно использовать одно и то же имя для функций, выполняющих разные действия и имеющих разные типы параметров. Шаблон определяет набор операторов, с помощью которых программы позже могут сами создать несколько функций.
Шаблоны – средство для реализации параметризированных классов функций на языке С++.
Template <class TYPE>
Void swap (TYPE &x, TYPE &y)
{
	TYPE temp;
	temp = x;
	x = y;
	y = temp;
}
Инстанцирование – генерация функции по шаблону и её аргументу.
Может быть и два типа (TYPE1, TYPE2), или параметр может быть стандартного типа (int)
Определяя шаблоны функций, вы заставляете компилятор С++ создавать в случае необходимости функции, которые отличаются типом возвращаемого значения или типами параметров.

    2. Шаблоны классов. Определение, пример.
Для создания объектов класса с использованием шаблоном программы просто ссылаются на имя класса, за которым внутри угловых скобок следуют типы, например, <int, float>
Если у класса есть конструктор, с помощью которого вы инициализируете элементы данных, вы можете вызвать этот конструктор при создании объекта с использованием шаблона.
Если компилятор С++ встречает объявление объекта, он создаёт класс из шаблона, используя соответствующие типы.
Шаблон класса определяет типонезависимый класс, который в дальнейшем служит для создания объектов требуемых типов. Если компилятор С++ встречает объявление объекта, основанное на шаблоне классе, то для построения класса требуемого типа он будет использовать типы, указанные при объявлении.
Template <class T, class T1>
class array
{T *data;
 int size;
 int index;
public:
	array (int size);
	T1 sum (void);
	T average_value (void);
	void show_array (void);
	int add_value (T); };
Сразу после имени класса вы должны указать типы класса, например: array <T, T1>::avg
Создание класса требуемого типа array<int, long> Kl1;
Объявление класса: 
Template_class_name<type1, type2> object_name (parameter1, parameter2)
Массив типа char, в котором 100 элементов:
Array<char, int> numbers (100)
Использование не типизированных параметров
template <typename T, int n>	
array <int, 100> S; создаст класс array с именем S, состоящий из 100 элементов типа int.
Свойства шаблона класса
Методы шаблона класса автоматически становятся шаблонами функций.
    1. Описание параметров шаблона в заголовке функции должно соответствовать шаблону класса.
    2. Локальные класса не могут иметь шаблоны в качестве своих элементов.
    3. Шаблоны методов не могут быть виртуальными.
    4. Шаблоны классов могут содержать статические элементы, дружественные функции и классы.
    5. Шаблоны могут быть производными как от шаблонов, так и от обычных классов, а также являться базовыми и для шаблонов, и для обычных классов
    6. Внутри шаблона нельзя определять friend-шаблоны.
Свойства параметров шаблона класса
    1. Параметры перечисляются через запятую, слово class (typename) требуется записывать перед каждым параметром. Template <class T1, class T2>
    2. Параметрам шаблонного класса можно присваивать значения по умолчанию
Специализация шаблона:
template <>
class List <int>

    3. Шаблоны классов и дружественность. Пример.
Дружественность может быть установлена:
    • Между шаблоном класса и глобальной функцией.
    • Методом другого класса (возможно, шаблонного) или даже целым классом (возможно, шаблонным).
Не параметризованная дружественная функция:
friend void f1 (int c) {}
Параметризованная дружественная функция:
friend void f2<T> (Myclass<T> &ob);
Дружественной для класса будет функция только для конкретного типа T (например, float)
Template <class T>
void f2 (Myclass<T> &ob);
Дружественные к шаблону класса методы другого класса
template <class T>
class X {… friend void A<int>::f4 (); //из класса А };

    4. Шаблоны классов и наследование. Пример.
    1) Обычный класс наследует шаблон класса
class ItemExt : public Item <int>{}
Когда Вы используете ItemExt, то вам не нужно указывать тип:
ItemExt int_item;
Класс не позволит использовать гибкость шаблонов.
    2) Шаблон класса наследует другой шаблон класса
Template <typename T>
class SmartItem : public Item <T> {};
Тогда при объявлении в main надо указать тип
SmartItem <int> c;

    5. Стандартная библиотека шаблонов. Контейнеры и итераторы. Примеры определения последовательных контейнеров. Заполнение контейнеров. Пример
Контейнеры - объекты для хранения однотипных данных: последовательные (vector, deque, list); ассоциативные (set, multiset, map, multimap). В STL определены два основных типа контейнеров: последовательности и ассоциативные контейнеры. Разница между ними состоит в том, что для последовательностей имеет значение порядок следования элементов (вектор, стек, очередь), а для ассоциативных контейнеров – нет (ассоциативный массив, множество). В каждом классе-контейнере определён набор функций для работы с ними. Ключевая идея для стандартных контейнеров заключается в том, что они должны быть взаимозаменяемыми, если это разумно для решения задачи.
Хранение элементов контейнера:
    • последовательно (непрерывным блоком) или
    • разбросаны по всей памяти
Доступ к элементам контейнера
    • по индексу (например,vector)
    • только последовательным перебором (list)
Вектор: хранение элементов единым блоком; доступ к любому элементу по индексу.
Очередь: хранение элементов единым блоком; доступ только к первому элементу, внесенному в очередь.
Список: элементы разбросаны по памяти - каждый элемент содержит указатель на последующий и предыдущий; доступ - только перебор.
Заполнение контейнеров можно осуществить либо через итераторы, либо через push_back().
Итераторы - объекты, которые используются для универсального доступа к элементам, хранящимся в контейнере любого типа. Они играют роль указателей, позволяют получить доступ к содержимому контейнера и сканировать его элементы.

    6. Стандартная библиотека шаблонов. Итераторы и примеры определения и работы с ними.
Итератор – это обобщённый "указатель" на элемент, хранящийся в контейнере
list<double> ls;                                     // объявлен список
list<double>::iterator it;                    //      объявлен итератор 
1) оператор * – разыменование и получение доступа к значению элемента
(*it)=5;
2) операторы «++» и «– –» получение указателя на следующий и предыдущий элемент
it++, it—
3) итератор на первый элемент контейнера
it=ls.begin()
4) итератор на следующий после последнего элемент контейнера
it=ls.end()
Существует пять типов итераторов:
1. Итераторы ввода (input iterator) поддерживают операции равенства, разыменования и инкремента: ==, !=, *i, ++i, i++, *i++. Специальным случаем итератора ввода является istream_iterator.
2. Итераторы вывода (output iterator) поддерживают операции разыменования, допустимые только с левой стороны присваивания, и инкремента: ++i, i++, *i = t, *i++ = t. Специальным случаем итератора вывода является ostream_iterator.
3. Однонаправленные итераторы (forward iterator) поддерживают все операции итераторов ввода/вывода и, кроме того, позволяют без ограничения применять присваивание: ==, !=, =, *i, ++i, i++, *i.
4. Двунаправленные итераторы (bidirectional iterator) обладают всеми свойствами forward-итераторов, а также имеют дополнительную операцию декремента (--i, i--, *i--), что позволяет им проходить контейнер в обоих направлениях.
5. Итераторы произвольного доступа (random access iterator) обладают всеми свойствами bidirectional-итераторов, а также поддерживают операции сравнения и адресной арифметики, то есть непосредственный доступ к элементу по индексу: i += n, i + n, i -= n, i - n, i1 - i2, i[n], i1 < i2, i1 <= i2, i1 > i2, i1 >= i2.

    7. Стандартная библиотека шаблонов. Общие свойства контейнеров. Операции с контейнерами. Примеры (размер контейнера, проверка пустой или нет и др.)
Ключевая идея для стандартных контейнеров заключается в том, что когда это представляется разумным, они должны быть логически взаимозаменяемыми. Пользователь может выбирать между ними, основываясь на соображениях эффективности и потребности в специализированных операциях. Например, если часто требуется поиск по ключу, можно воспользоваться map (ассоциативным массивом). С другой стороны, если преобладают операции, характерные для списков, можно воспользоваться контейнером list. Если добавление и удаление элементов часто производится в концы контейнера, следует подумать об использовании очереди queue, очереди с двумя концами deque, стека stack. По умолчанию пользователь должен использовать vector ; он реализован, чтобы хорошо работать для самого широкого диапазона задач.
В STL определены следующие классы-контейнеры (в угловых скобках указаны заголовочные файлы, где определены эти классы):
    • bitset - множество битов <bitset.h>
    • vector - динамический массив <vector.h>
    • list - линейный список <list.h>
    • deque - двусторонняя очередь <deque.h>
    • stack - стек <stack.h>
    • queue - очередь <queue.h>
    • priority_queue - очередь с приоритетом <queue.h>
    • map - ассоциативный список для хранения пар ключ/значение, где с каждым ключом связано одно значение <map.h>
    • multimap - с каждым ключом связано два или более значений <map.h>
    • set - множество <set.h>
    • multiset - множество, в котором каждый элемент не обязательно уникален <set.h>
Доступ к элементам:
    • front() - ссылка на первый элемент
    • back() - ссылка на последний элемент
Включение элементов:
    • insert(p, x) - добавление х перед элементом, на который указывает р
    • insert(p, n, x) - добавление n копий х перед р
    • insert(p, first, last) - добавление элементов из [first:last] перед р
    • push_back(x) - добавление х в конец
    • push_front(x) - добавление нового первого элемента (только для списков и очередей с двумя концами)
Удаление элементов
    • pop_back() - удаление последнего элемента
    • pop_front() - удаление первого элемента (только для списков и очередей с двумя концами)
    • erase(p) - удаление элемента в позиции р
    • erase(first, last) - удаление элементов из [first:last]
    • clear() - удаление всех элементов
Другие операции
    • size() - число элементов
    • empty() - контейнер пуст?
    • capacity() - память, выделенная под вектор (только для векторов)
    • reserve(n) - выделяет память для контейнера под n элементов
    • resize(n) - изменяет размер контейнера (только для векторов, списков и очередей с двумя концами)
    • swap(x) - обмен местами двух контейнеров
    • ==, !=, < операции сравнения

    8. Стандартная библиотека шаблонов. Алгоритмы. Примеры работы со стандартными алгоритмами)
Алгоритмы – обобщенные процедуры для обработки элементов любых контейнеров.
#include <algorithm>
Алгоритмы, не модифицирующие контейнер – процедуры поиска и сравнения.
list<string> ls;
list<string>::const_iterator it;
// поиск значения "К8" в диапазоне от ls.begin() до ls.end()
it=find(ls.begin(), ls.end(), "К8"); 
Алгоритмы, модифицирующие значение элементов контейнера, но не изменяющие порядок их следования – выполнение действий над каждым элементом контейнера, поиск и замена
vector<int> v(100);
// заполнение всех элементов от ls.begin() до ls.end() значением 0             
fill(v.begin(), v.end(), 0);
// замена всех элементов от ls.begin() до ls.end() равных -1 на 1    
replace(v.begin(), v.end(), -1, 1); 
Алгоритмы, модифицирующие контейнер – функции копирования, перестановок, удаления и сортировки, разбиения и слияния последовательностей
vector<int> v(100);
// сортировка массива
sort(v.begin(), v.end());
// перестановка элементов массива в обратном порядке
reverse(v.begin(), v.end());
Функции-помощники (перестановки и сравнения)
vector<int> v(100);
vector<int>::iterator it=v.begin();
it++;
swap(*v.begin(), *it);
Алгоритмы min_element() и max_element() находят минимальный и максимальный элементы в контейнере:
for_each - выполнение пользовательской функции (в данном случае, вывода в консоль) для каждого элемента вектора.
replace_if - замена с условием.

    9. Стандартная библиотека шаблонов. Последовательные контейнеры. Примеры vector.
В шаблоне vector определены операция присваивания и метод копирования (assign).Векторы можно присваивать друг другу так же, как стандартные типы данных или строки. После присваивания размер вектора становится равным новому значению, все старые элементы удаляются.
Память под вектор выделяется динамически, но не под один элемент в каждый момент времени, а сразу под группу элементов, например 256 или 1024. Перераспределение памяти происходит только при превышении количества элементов, при этом объем выделенного пространства удваивается. После перераспределения любые итераторы, ссылающиеся на элементы вектора, становятся недействительными, поскольку вектор может быть перемещен в другой участок памяти и нельзя ожидать, что связанные с ним ссылки будут обновлены автоматически.
Пример.
include <vector>
using namespace std;
vector<double> x;                               // создание вектора
 x.resize(10);                                        // изменение размера вектора
x.resize(x.size()+100);                        // изменение размера вектора
double sum=0.0;
for(int i=0; i<x.size(); i++)
{
    sum+=x[i];                                              //доступ по индексу к элементам вектора
}
Функции работы с контейнером – vector:
    1. Для любого объекта, который будет храниться в векторе, должен быть определен конструктор по умолчанию, определены операторы < и ==.
    2. Для класса вектор определены операторы сравнения ==, <, <=, !=, >, >=. Кроме этого, для класса vector определяется оператор индекса []. x[i]=5
    3. Новые элементы могут включаться с помощью функций insert(), push_back(), resize(), assign(). x.resize(100); int n=x.size(); x.push_back(7)
    4. Существующие элементы могут удаляться с помощью функций erase(), pop_back(), resize(), clear(). x.clear(); //разрушает все элементы и освобождает контейнер
    5. Доступ к отдельным элементам осуществляется с помощью итераторов begin(), end(), rbegin(), rend().
    6. Определить  пустой ли контейнер
bool  res=x.empty();                              // эквивалентно x.size() == 0
      7.   Выделить дополнительную память  для размещения новых элементов 
x.reserve(200);

    10.  Стандартная библиотека шаблонов. Последовательные контейнеры. Примеры list.
Список – структура данных для организации хранения элементов с эффективной вставкой и удаления в любом месте этой структуры, не требует доступа по индексу
УЗЕЛ (Node) – объект, который содержит ссылки на последующий и предыдущий элементы, а также значение данного элемента списка
В  STL – простой двухсвязный список 
list<int> example;             //создание списка
example.push_back(0);       // вставка в конец
example.push_front(1); // вставка в начало 
example.insert(x.begin(), 3); // вставка в любое место списка 

