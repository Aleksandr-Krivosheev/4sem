Ядро библиотеки образуют три элемента: контейнеры, алгоритмы и
итераторы.
Контейнеры (containers) - это объекты, предназначенные для
хранения набора элементов. Например, вектор, линейный список,
множество. Aссоциативные контейнеры (associative containers)
позволяют с помощью ключей получить быстрый доступ к
хранящимся в них значениям. В каждом классе-контейнере
определен набор функций для работы с ними. Например,
контейнер "список" содержит функции для вставки, удаления и
слияния элементов.
Алгоритмы (algorithms) выполняют операции над содержимым
контейнера. Существуют алгоритмы для инициализации,
сортировки, поиска, замены содержимого контейнеров. Многие
алгоритмы предназначены для работы с последовательностью
(sequence), которая представляет собой линейный список
элементов внутри контейнера.
Итераторы (iterators) - это объекты, которые по отношению к
контейнеру играют роль указателей. Они позволяют получить
доступ к содержимому контейнера и сканировать его элементы,
примерно так же, как указатели используются для доступа к
элементам массива. С итераторами можно работать так же, как с
указателями. К ним можно применять операции *, инкремент,
декремент. Тип итератора iterator определён в различных
контейнерах. 

Итераторы (iterators) - это объекты, которые по отношению к контейнеру играют роль указателей. Они позволяют получить доступ к содержимому контейнера и сканировать его элементы, примерно так же, как указатели используются для доступа к элементам массива. С итераторами можно работать так же, как с указателями. К ним можно применять операции *, инкремент, декремент. Тип итератора iterator определён в различных контейнерах.
Существует пять типов итераторов:
1. Итераторы ввода (input iterator) поддерживают операции равенства, разыменования и инкремента: ==, !=, *i, ++i, i++, *i++. Специальным случаем итератора ввода является istream_iterator.
2. Итераторы вывода (output iterator) поддерживают операции разыменования, допустимые только с левой стороны присваивания, и инкремента: ++i, i++, *i = t, *i++ = t. Специальным случаем итератора вывода является ostream_iterator.
3. Однонаправленные итераторы (forward iterator) поддерживают все операции итераторов ввода/вывода и, кроме того, позволяют без ограничения применять присваивание: ==, !=, =, *i, ++i, i++, *i.

Функтор — это сокращение от функциональный объект, представляющий собой конструкцию, позволяющую использовать объект класса как функцию. В C++ для определения функтора достаточно описать класс, в котором переопределена операция ().
Выгода функтора состоит в том, что
 а) его можно параметризовать при создании объекта (перед вызовом) используя конструктор объекта с параметрами 
б) может создаваться временный объект исключительно на время выполнения функционального вызова

Особый смысл функторы приобрели в алгоритмах STL, когда они передаются в вызов в качестве параметра, вместо функции, определяющей действие или предикат алгоритма.
Класс функтора, т.е. класса с перегруженным оператором operator() является полноценным классом и может содержать конструкторы, дополнительные методы а также внутренние данные. Кроме того, как и обычная функция operator() может быть перегружен, чтобы принимать различное количество аргументов и возвращать значение какого- либо типа. Рассмотрим пример функтора, для которого перегружено несколько версий operator(), принимающих различное количество аргументов.
