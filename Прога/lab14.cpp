// Вариант №11

// Задание:
// мультиграф

// Итерационный алгоритм компоновки. Есть разрезанная по платам схема. Задано число плат,  количество элементов  и перечень номеров
// элементов на каждой плате, задана  исходная схема соединений элементов до разрезания (модель мультиграф). Необходимо вычислить
// суммарное число ребер, попавших в разрез (то есть между платами) и,  используя итерационный алгоритм попарных перестановок между
// платами уменьшить суммарное число ребер, попавших в разрез. 

//===================================================================================================================================

#include <iostream>   // для cin / cout, самый простой и удобный ввод и вывод
#include <string>     // для использования переменных класса string (строка)
#include<iomanip>     // для функции setw() и left - красивый вывод. Пример: left << setw(3) << "12" выделение 3-ех ячеек для 
// символов _ _ _ (только без пробелов). left - ввод слева: 12_ (_ становится пробелом)
#include <fstream>    // для работы с файлами
#include <vector>     // для работы с переменными vector

using namespace std;  // для ввода и вывода через консоль (cin / cout)

//===================================================================================================================================

// Manual_input - "Ручной ввод" - выполняет функцию ввода всех данных для матрицы-смежности с помощью консольного приложения.
// quantity_N - "количество N" - количество элементов в схеме.
// quantity_L - "количество L" - количество цепей в схеме.
// matrices - "матрицы" - матрица-смежности.
// good_bad - "хорошо плохо" - создалась ли матрица?
void Manual_input(int& quantity_N, int& quantity_L, int**& matrices, bool& good_bad) // & для того, чтобы переменная могла изменяться в функции
{
    cout << "Введите количество элементов в схеме: N = "; 
    cin >> quantity_N; // ввод количества элементов (вершин) в схеме
    // нарушена логика! количества вершин не может быть меньше 0.
    while (quantity_N < 0) // делай пока (количество вершин меньше нуля)
    {
        cout << endl;
        cout << "ОШИБКА. ОТРИЦАТЕЛЬНОЕ ЗНАЧЕНИЕ quantity_N. Повторите ввод." << endl;
        cout << "Введите количество элементов в схеме: N = "; cin >> quantity_N; // повторяем ввод количества вершин в схеме
    }

    cout << "Введите количество цепей в схеме:     L = "; cin >> quantity_L; // ввод количества цепей в схеме
     // нарушена логика! количества цепей не может быть меньше 0.
    while (quantity_L < 0) // делай пока (количество цепей меньше нуля)
    {
        cout << endl;
        cout << "ОШИБКА. ОТРИЦАТЕЛЬНОЕ ЗНАЧЕНИЕ quantity_L. Повторите ввод." << endl;
        cout << "Введите количество цепей в схеме:     L = "; cin >> quantity_L; // повторяем ввод количества цепей в схеме
    }

    // создаём динамическую матрицу-смежности (выделение памяти)
    matrices = new int* [quantity_N]; // создаем quantity_N строк (выделение памяти)
    for (int i = 0; i < quantity_N; i++)
    {
        matrices[i] = new int[quantity_N]; // для каждой строки создать элементы, их количество равно количетву столбцов - quantity_N (выделение памяти)
    }
    cout << endl;

    cout << "Ввод данных для матрицы смежности." << endl;
    int sum_l = 0; // проверочная переменная - проверяет количество цепей в матрице-смежности
    // так как матрица-смежности симметрична, то вводим элементы выше главной диагонали:
    // 1 1 1 1
    // - 1 1 1
    // - - 1 1
    // - - - 1 где 1-цы вводятся элементы
    for (int i = 0; i < quantity_N; i++)
    {
        for (int j = i; j < quantity_N; j++)
        {
            cout << "Введите количество рёбер, соединяющих вершину V" << left << setw(3) << i + 1 << " и вершину V" << left << setw(3) << j + 1 << ": ";
            cin >> matrices[i][j]; // ввод элемента матрицы-смежности
            sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
            // нарушение логики ввода элемента матрицы-смежности: если превышено количество возможных цепей в схеме (quantity_L) + количество рёбер между вершинами не может быть отрицательным
            while ((sum_l > quantity_L) || (matrices[i][j] < 0)) // делай пока (превышено количество цепей в схеме) или (количество рёбер меньше нуля - отрицательно)
            {
                if (sum_l > quantity_L) // если "превышено количество цепей в схеме"
                {
                    cout << endl;
                    cout << "ОШИБКА. ПРЕВЫШЕНО КОЛИЧЕСТВО ВОЗМОЖНЫХ ЦЕПЕЙ. Повторите ввод." << endl;
                    sum_l -= matrices[i][j]; // так как заменяется элемент матрицы смежности (колиечтво ребер между вершинами)
                    cout << "Введите количество рёбер, соединяющих вершину V" << left << setw(3) << i + 1 << " и вершину V" << left << setw(3) << j + 1 << ": ";
                    cin >> matrices[i][j]; // повторяем ввод элемента матрицы-смежности
                    sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
                }
                if (matrices[i][j] < 0) // если "количество рёбер меньше нуля - отрицательно"
                {
                    cout << endl;
                    cout << "ОШИБКА. ЭЛЕМЕНТЫ МАТРИЦЫ СМЕЖНОСТИ НЕ МОГУТ БЫТЬ ОТРИЦАТЕЛЬНЫМИ. Повторите ввод." << endl;
                    sum_l -= matrices[i][j]; // так как заменяется элемент матрицы смежности (колиечтво ребер между вершинами)
                    cout << "Введите количество рёбер, соединяющих вершину V" << left << setw(3) << i + 1 << " и вершину V" << left << setw(3) << j + 1 << ": ";
                    cin >> matrices[i][j]; // повторяем ввод элемента матрицы-смежности
                    sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
                }
            }
        }
    }
    // нельзя создать матрицу смежности из 0 вершин и при этом если связей будет больше нуля 
    if ((quantity_N == 0) && (quantity_L > 0))
    {
        cout << endl;
        cout << "НЕВОЗМОЖНО СОЗДАТЬ МАТРИЦУ СМЕЖНОСТИ. Завершение программы." << endl;
        good_bad = false; // не смогли создать матрицу-смежности
    }
    else // матрицу-смежности создали
    {
        if (sum_l != quantity_L) // не было достигнуто нужного количества цепей (quantity_L)
        {
            cout << endl;
            cout << "ОШИБКА. НЕДОСТАТОЧНОЕ КОЛИЧЕСТВО ЦЕПЕЙ В СХЕМЕ. Автоматическое исправление." << endl;
            matrices[0][0] = quantity_L - sum_l + matrices[0][0]; // (quantity_L - sum_l) - сколько не хватило до нужного количества цепей.
            // Прибавляем текущее значение элемент матрицы-смежности (+ matrices[0][0]), иначе смысл исправления ошибки?
        }
    }
    // не забываем симметрию!!!
    // - - - -
    // 1 - - -
    // 1 1 - -
    // 1 1 1 - , где 1-цы это заполняющиеся элементы матрицы-смежности. Симметрия относительно главной диагонали
    for (int i = 1; i < quantity_N; i++)
    {
        for (int j = 0; j < i; j++)
        {
            matrices[i][j] = matrices[j][i]; // присваивание - симметрия
        }
    }
}

//===================================================================================================================================

// File_input - "Файловый ввод" - выполняет функцию ввода всех данных для матрицы-смежности с помощью файла IN.txt.
// quantity_N - "количество N" - количество элементов в схеме.
// quantity_L - "количество L" - количество цепей в схеме.
// matrices - "матрицы" - матрица-смежности.
// good_bad - "хорошо плохо" - создалась ли матрица?
void File_input(int& quantity_N, int& quantity_L, int**& matrices, bool& good_bad) // & для того, чтобы переменная могла изменяться в функции
{
    ifstream file_in("C:\\Users\\Данил\\Desktop\\учеба 4 сем\\ЛИПО\\lab14_komponovka\\lab14\\IN.txt"); // открывем файл для чтения. 
    file_in >> quantity_N; // считываем с файла количество вершин (элементов) в схеме
    file_in >> quantity_L; // считываем с файла количество цепей в схеме
    // создаём динамическую матрицу-смежности (выделение памяти)
    matrices = new int* [quantity_N]; // создаем quantity_N строк (выделение памяти)
    for (int i = 0; i < quantity_N; i++)
    {
        matrices[i] = new int[quantity_N]; // для каждой строки создать элементы, их количество равно количетву столбцов - quantity_N (выделение памяти)
    }
    // создаем точно такого же размера дополнительную матрицу-смежности - чтобы не дергать курсор внутри файла, а работать по привычной схеме. 
    // Считывать элементы выше главной диагонали + сама диагональ
    int** dop_matrices = new int* [quantity_N]; // создаем quantity_N строк (выделение памяти)
    for (int i = 0; i < quantity_N; i++)
    {
        dop_matrices[i] = new int[quantity_N]; // для каждой строки создать элементы, их количество равно количетву столбцов - quantity_N (выделение памяти)
    }
    // 1 1 1 1
    // 1 1 1 1
    // 1 1 1 1
    // 1 1 1 1 , где 1-цы это считываемые элементы из файла
    for (int i = 0; i < quantity_N; i++)
    {
        for (int j = 0; j < quantity_N; j++)
        {
            file_in >> dop_matrices[i][j]; // считываем элемент из файла - элемент матрицы-смежности
        }
    }
    int sum_l = 0; // проверочная переменная - проверяет количество цепей в матрице-смежности
    // так как матрица-смежности симетрична, то вводим элементы выше главной диагонали:
    // 1 1 1 1
    // - 1 1 1
    // - - 1 1
    // - - - 1 где 1-цы это присваемываемые элементы из дополнительной матрицы
    for (int i = 0; i < quantity_N; i++)
    {
        for (int j = i; j < quantity_N; j++)
        {
            matrices[i][j] = dop_matrices[i][j]; // а вот и само присваивание
            sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
            // нарушение логики ввода элемента матрицы-смежности: если превышено количество возможных цепей ...
            // ... в схеме (quantity_L) + количество рёбер между вершинами не может быть отрицательным
            while ((sum_l > quantity_L) || (matrices[i][j] < 0))
            {
                if (sum_l > quantity_L) // если "превышено количество цепей в схеме"
                {
                    cout << endl;
                    cout << "ОШИБКА ВВОДА (строка " << i + 1 << " столбец " << j + 1 << "). ПРЕВЫШЕНО КОЛИЧЕСТВО ВОЗМОЖНЫХ ЦЕПЕЙ. Автоматическое исправление." << endl;
                    sum_l -= matrices[i][j];  // так как заменяется элемент матрицы смежности (колиечтво ребер между вершинами)
                    matrices[i][j] = rand() % (1 + 1); // генерация числа в интервале [0; 1]
                    sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
                }
                if (matrices[i][j] < 0) // если "количество рёбер меньше нуля - отрицательно"
                {
                    cout << endl;
                    cout << "ОШИБКА ВВОДА (строка " << i + 1 << " столбец " << j + 1 << "). ОТРИЦАТЕЛЬНОЕ ЗНАЧЕНИЕ ЭЛЕМЕНТА МАТРИЦЫ СМЕЖНОСТИ matrices. Автоматическое исправление." << endl;
                    sum_l -= matrices[i][j]; // так как заменяется элемент матрицы смежности (колиечтво ребер между вершинами)
                    matrices[i][j] = 0; // присваиваем ноль
                    sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
                }
            }
        }
    }

    // нельзя создать матрицу смежности из 0 вершин и при этом если связей будет больше нуля
    if ((quantity_N == 0) && (quantity_L > 0))
    {
        cout << endl;
        cout << "НЕВОЗМОЖНО СОЗДАТЬ МАТРИЦУ СМЕЖНОСТИ. Завершение программы." << endl;
        good_bad = false; // не смогли создать матрицу-смежности
    }
    else // матрицу-смежности создали
    {
        if (sum_l != quantity_L) // не было достигнуто нужного количества цепей (quantity_L)
        {
            cout << endl;
            cout << "ОШИБКА ВВОДА. НЕДОСТАТОЧНОЕ КОЛИЧЕСТВО ЦЕПЕЙ В СХЕМЕ. Автоматическое исправление." << endl;
            matrices[0][0] = quantity_L - sum_l + matrices[0][0]; // (quantity_L - sum_l) - сколько не хватило до нужного количества цепей.
            // Прибавляем текущее значение элемент матрицы-смежности (+ matrices[0][0]), иначе смысл исправления ошибки?
        }
    }
    // не забываем симметрию!!!
    // - - - -
    // 1 - - -
    // 1 1 - -
    // 1 1 1 - , где 1-цы это заполняющиеся элементы матрицы-смежности. Симетрия относительно главной диагонали
    for (int i = 1; i < quantity_N; i++)
    {
        for (int j = 0; j < i; j++)
        {
            if (dop_matrices[i][j] != matrices[j][i])
            {
                cout << endl;
                cout << "ОШИБКА ВВОДА (строка " << i + 1 << " столбец " << j + 1 << "). НЕККОРЕКТНЫЕ ЗНАЧЕНИЯ В ФАЙЛЕ IN.txt. Автоматическое исправление." << endl;
                cout << "Замена элемента R" << i + 1 << j + 1 << " на элемент R" << j + 1 << i + 1;
            }
            matrices[i][j] = matrices[j][i]; // присваивание - симметрия
        }
    }
    // дополнительная матрица больше не нужна - удаляем ее (очищение памяти)
    for (int i = 0; i < quantity_N; i++)
    {
        delete[] dop_matrices[i];
    }
    delete[] dop_matrices;
    file_in.close(); // закрыаем файл
}

//===================================================================================================================================

// Generated_input - "Сгенерированный ввод" - выполняет функцию ввода всех данных для матрицы смежности с помощью генерации.
// quantity_N - "количество N" - количество элементов в схеме.
// quantity_L - "количество L" - количество цепей в схеме.
// matrices - "матрицы" - матрица-смежности.
// good_bad - "хорошо плохо" - создалась ли матрица?
void Generated_input(int& quantity_N, int& quantity_L, int**& matrices, bool& good_bad) // & для того, чтобы переменная могла изменяться в функции
{
    int left_border, right_border; // левая и правая граница генерации
    cout << "Генерация количества элементов в схеме." << endl;
    cout << "Введите левую границу генерации:  left_border  = "; cin >> left_border; // ввод левой границы генерации
    // нарушение логики - количество вершин не может быть меньше нуля
    while (left_border < 0) // делай пока (левая граница меньше нуля - отрицательна)
    {
        cout << endl;
        cout << "ЛЕВАЯ ГРАНИЦА НЕ МОЖЕТ БЫТЬ МЕНЬШЕ НУЛЯ. Повторите ввод." << endl;
        cout << "Введите левую границу генерации:  left_border  = "; cin >> left_border; // повторный ввод левой границы генерации
    }
    cout << "Введите правую границу генерации: right_border = "; cin >> right_border; // ввод правой границы генерации
    // нарушение логики правая граница не может быть меньше левой границы
    while (right_border < left_border) // делай пока (правая граница меньше левой)
    {
        cout << endl;
        cout << "ПРАВАЯ ГРАНИЦА НЕ МОЖЕТ БЫТЬ МЕНЬШЕ ЛЕВОЙ. Повторите ввод." << endl;
        cout << "Введите правую границу генерации: right_border = "; cin >> right_border; // повторный ввод правой границы генерации
    }
    quantity_N = left_border + rand() % (right_border - left_border + 1); // генерация в интервале: [left_border; right_border]
    cout << "Генерация количества элементов в схеме: N = " << quantity_N << endl;

    cout << endl;

    cout << "Генерация количества цепей в схеме." << endl;
    cout << "Введите левую границу генерации:  left_border  = "; cin >> left_border; // ввод левой границы генерации
    // нарушение логики - количество вершин не может быть меньше нуля
    while (left_border < 0) // делай пока (левая граница меньше нуля - отрицательна)
    {
        cout << endl;
        cout << "ЛЕВАЯ ГРАНИЦА НЕ МОЖЕТ БЫТЬ МЕНЬШЕ НУЛЯ. Повторите ввод." << endl;
        cout << "Введите левую границу генерации:  left_border  = "; cin >> left_border; // повторный ввод левой границы генерации
    }
    cout << "Введите правую границу генерации: right_border = "; cin >> right_border; // ввод правой границы генерации
    // нарушение логики правая граница не может быть меньше левой границы
    while (right_border < left_border) // делай пока (правая граница меньше левой)
    {
        cout << endl;
        cout << "ПРАВАЯ ГРАНИЦА НЕ МОЖЕТ БЫТЬ МЕНЬШЕ ЛЕВОЙ. Повторите ввод." << endl;
        cout << "Введите правую границу генерации: right_border = "; cin >> right_border; // повторный ввод правой границы генерации
    }
    quantity_L = left_border + rand() % (right_border - left_border + 1); // генерация в интервале: [left_border; right_border]
    cout << "Генерация количества цепей в схеме:     L = " << quantity_L << endl;
    // создаём динамическую матрицу-смежности (выделение памяти)
    matrices = new int* [quantity_N]; // создаем quantity_N строк (выделение памяти)
    for (int i = 0; i < quantity_N; i++)
    {
        matrices[i] = new int[quantity_N]; // для каждой строки создать элементы, их количество равно количетву столбцов - quantity_N (выделение памяти)
    }

    cout << endl;

    int sum_l = 0;  // проверочная переменная - проверяет количество цепей в матрице-смежности
    double dop = quantity_L / quantity_N / 2;  // правая граница для элементов матрицы-смежности - можно просто присвоить простое число 1 или 2
    right_border = 1 + int(dop); // правая граница - из вещественного числа dop делаем целое - int(dop)
    cout << "Генерация матрицы смежности." << endl;
    // так как матрица-смежности симетрична, то вводим элементы выше главной диагонали:
    // 1 1 1 1
    // - 1 1 1
    // - - 1 1
    // - - - 1 где 1-цы это генерируемы элементы матрицы-смежности
    for (int i = 0; i < quantity_N; i++)
    {
        for (int j = i; j < quantity_N; j++)
        {
            matrices[i][j] = rand() % (right_border + 1); // генерация в интервале: [0; right_border]
            sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
            // нарушение логики ввода элемента матрицы-смежности: если превышено количество возможных цепей в схеме (quantity_L)
            while (sum_l > quantity_L) // делай пока (превышено количество цепей в схеме)
            {
                sum_l -= matrices[i][j]; // так как заменяется элемент матрицы смежности (колиечтво ребер между вершинами)
                matrices[i][j] = rand() % (1 + 1); // повторяем генерацию в интервале: [0; 1]
                sum_l += matrices[i][j]; // прибавляем количество рёбер, для проверки превысили ли мы предел quantity_L - количества цепей
            }
        }
    }
    // не забываем симметрию!!!
    // - - - -
    // 1 - - -
    // 1 1 - -
    // 1 1 1 - , где 1-цы это заполняющиеся элементы матрицы-смежности. Симетрия относительно главной диагонали
    for (int i = 1; i < quantity_N; i++)
    {
        for (int j = 0; j < i; j++)
        {
            matrices[i][j] = matrices[j][i]; // присваивание - симетрия
        }
    }
    // нельзя создать матрицу смежности из 0 вершин и при этом если связей будет больше нуля
    if ((quantity_N == 0) && (quantity_L > 0))
    {
        cout << endl;
        cout << "НЕВОЗМОЖНО СОЗДАТЬ МАТРИЦУ СМЕЖНОСТИ. Завершение программы." << endl;
        good_bad = false; // не смогли создать матрицу-смежности
    }
}

//===================================================================================================================================

// Delete - "Удаление" - удаление матрицы-смежности (очищение памяти).
// quantity_N - "количество N" - количество элементов в схеме.
// matrices - "матрицы" - матрица-смежности.
void Delete(int& quantity_N, int**& matrices) // & для того, чтобы переменная могла изменяться в функции
{
    cout << "------------------------УДАЛЕНИЕ  ДАННЫХ-----------------------" << endl;

    for (int i = 0; i < quantity_N; i++)
    {
        delete[] matrices[i];
    }
    delete[] matrices;
    cout << "Память очищена." << endl;
}

//===================================================================================================================================

// Confirm_input - "Подтверждение ввода" - выполняет функцию вывода матрицы-смежности.
// quantity_N - "количество N" - количество элементов в схеме.
// matrices - "матрицы" - матрица-смежности.
void Confirm_input(int& quantity_N, int& quantity_L, int**& matrices) // & для того, чтобы переменная могла изменяться в функции
{
    cout << "Данные матрицы смежности:" << endl;
    // как выглядить будет:
    //    V1 V2 V3 V4
    // V1 1  1  1  1
    // V2 1  1  1  1
    // V3 1  1  1  1
    // V4 1  1  1  1
    cout << "    ";
    //    V1 V2 V3 V4...
    for (int i = 0; i < quantity_N; i++)
    {
        cout << " V" << left << setw(3) << i + 1; // setw() - объяснена в библиотеке вверху - красивый вывод
    }
    cout << endl;
    for (int i = 0; i < quantity_N; i++)
    {
        cout << "V" << left << setw(3) << i + 1; // Vi
        for (int j = 0; j < quantity_N; j++)
        {
            cout << " " << left << setw(4) << matrices[i][j]; // вывод элемента матрицы-смежности
        }
        // имеем Vi 1  1  1  1
        cout << endl; // переход на следующую строку
    }
    cout << endl;
    cout << "Количество цепей в схеме: " << quantity_L << endl;
}


//===================================================================================================================================

// Quantity_connections - "Количество выводов" - выполняет функцию подсчёта количества выводов на плате.
// plata      - плата - содержит вершины.
// quantity_N - количество элементов в схеме.
// matrices   - матрица-смежности.
int Quantity_connections(vector<int>& plata, int& quantity_N, int**& matrices) // & для того, чтобы переменная могла изменяться в функции
{
    int quantity_connections = 0; // количеств выводов
    bool FLG;
    for (int i = 0; i < plata.size(); i++)
    {
        for (int j = 0; j < plata[i]; j++) // проходим в интервале вершин [0; plata[i])
        {
            FLG = false; // предположим, что j не входит в состав платы
            for (int k = 0; k < plata.size(); k++)
            {
                if (plata[k] == j) // если "j входит в сотав платы"
                {
                    FLG = true; // поднимаем флажок
                }
            }
            if (FLG == false) // если "j не входит в сотав платы"
            {
                quantity_connections += matrices[plata[i]][j]; // прибавляем элемент матрицы-смежности
            }
        }
        for (int j = plata[i] + 1; j < quantity_N; j++) // проходим в интервале вершин (plata[i]; quantity_N]
        {
            FLG = false; // предположим, что j не входит в сотав платы
            for (int k = 0; k < plata.size(); k++)
            {
                if (plata[k] == j) // если "j входит в сотав платы"
                {
                    FLG = true; // поднимаем флажок
                }
            }
            if (FLG == false) // если "j не входит в сотав платы"
            {
                quantity_connections += matrices[plata[i]][j]; // прибавляем элемент матрицы-смежности
            }
        }
    }
    return quantity_connections;
}

//===================================================================================================================================

bool W(vector<int>& chast_1, vector<int>& chast_2, int** matr, int& quantity_N)
{
    int* a = new int[quantity_N];
    for (int i = 0; i < quantity_N; i++)
    {
        a[i] = 0;
    }
    for (int i = 0; i < chast_1.size(); i++)
    {
        for (int j = 0; j < chast_2.size(); j++)
        {
            a[chast_1[i]] += matr[chast_1[i]][chast_2[j]];
        }
        for (int j = 0; j < i; j++)
        {
            a[chast_1[i]] -= matr[chast_1[i]][chast_1[j]];
        }
        for (int j = i + 1; j < chast_1.size(); j++)
        {
            a[chast_1[i]] -= matr[chast_1[i]][chast_1[j]];
        }
    }

    for (int i = 0; i < chast_2.size(); i++)
    {
        for (int j = 0; j < chast_1.size(); j++)
        {
            a[chast_2[i]] += matr[chast_2[i]][chast_1[j]];
        }
        for (int j = 0; j < i; j++)
        {
            a[chast_2[i]] -= matr[chast_2[i]][chast_2[j]];
        }
        for (int j = i + 1; j < chast_2.size(); j++)
        {
            a[chast_2[i]] -= matr[chast_2[i]][chast_2[j]];
        }
    }

    vector<vector<int>> w;
    vector<int> dop;
    for (int i = 0; i < chast_1.size(); i++)
    {
        cout << "Для вершины V" << chast_1[i] + 1 << ":" << endl;
        for (int j = 0; j < chast_2.size(); j++)
        {
            cout << "V" << chast_2[j] + 1 << " | ";
            cout << "W" << chast_1[i] + 1 << chast_2[j] + 1 << " = " << "a" << chast_1[i] + 1 << " + " << "a" << chast_2[j] + 1 << " = ";
            cout << a[chast_1[i]] << " + " << a[chast_2[j]] << " = " << a[chast_1[i]] + a[chast_2[j]] << endl;
            dop.push_back(a[chast_1[i]] + a[chast_2[j]]);
        }
        w.push_back(dop);
        dop.clear();
    }

    cout << endl;
    cout << "--------------------ПЕРЕСТАНОВОЧНАЯ  МАТРИЦА---------------" << endl;

    cout << "   ";
    for (int i = 0; i < chast_2.size(); i++)
    {
        cout << "V" << left << setw(3) << chast_2[i] + 1;
    }
    cout << endl;
    for (int i = 0; i < chast_1.size(); i++)
    {
        cout << "V" << chast_1[i] + 1;
        for (int j = 0; j < chast_2.size(); j++)
        {
            cout << " " << left << setw(3) << w[i][j];
        }
        cout << endl;
    }
    delete[] a;
    int max = w[0][0];
    int i_max = chast_1[0];
    int j_max = chast_2[0];
    for (int i = 0; i < chast_1.size(); i++)
    {
        for (int j = 0; j < chast_2.size(); j++)
        {
            if (w[i][j] > max)
            {
                max = w[i][j];
                i_max = chast_1[i];
                j_max = chast_2[j];
            }
        }
    }
    cout << endl;
    cout << "Максимальное значения дают вершины V" << i_max + 1 << " и V" << j_max + 1 << ": " << max << endl;

    cout << endl;
    cout << "----------------------------------------------------------------" << endl;


    bool FLG;
    if (max > 0)
    {
        FLG = false;
        int i = 0;
        while (chast_1[i] != i_max)
        {
            i++;
        }
        chast_1[i] = j_max;

        i = 0;
        while (chast_2[i] != j_max)
        {
            i++;
        }
        chast_2[i] = i_max;

        cout << "В первую область входят вершины:   " << chast_1[0] + 1;
        for (int i = 1; i < chast_1.size(); i++)
        {
            cout << ", " << chast_1[i] + 1;
        }
        cout << endl;

        cout << "Во вторую область входят вершины:  " << chast_2[0] + 1;
        for (int i = 1; i < chast_2.size(); i++)
        {
            cout << ", " << chast_2[i] + 1;
        }
        cout << endl;

        cout << "----------------------------------------------------------------" << endl;
    }
    else
    {
        FLG = true;
    }
    return FLG;
}

int Col(vector<int>& plata_1, vector<int>& plata_2, int& quantity_N, int**& matrices) // & для того, чтобы переменная могла изменяться в функции
{
    int quantity_connections = 0; // количеств ребер после разреза
    for (int i = 0; i < plata_1.size(); i++)
    {
        for (int j = 0; j < plata_2.size(); j++)
        {
            quantity_connections += matrices[plata_1[i]][plata_2[j]];
        }
    }
    return quantity_connections;
}



//===================================================================================================================================

int main()
{
    setlocale(LC_ALL, "Russian"); // подключаем русификатор (кириллица в консоли). РОССИЯ! РОССИЯ! РОССИЯ!

    cout << "----------------------ВВОД МАТРИЦЫ СМЕЖНОСТИ---------------------" << endl;

    int quantity_N = 0; // количество вершин в матрице-смежности
    int quantity_L; // количество цепей в матрице-смежности
    int** matrices; // матрица-смежности
    bool good_bad = true; // соблюдена ли логика при создании матрицы-смежности (см. далее по коду)
    string choice; // выбор способа ввода матрицы-смежности

    // выбираем удобный варивнт для создания (ввода) матрицы-смежности
    cout << "Выберите удобный вариант для ввода количества элементов и цепей в схеме: " << endl;
    cout << "1. Ввод с клавиатуры." << endl;
    cout << "2. Ввод из файла." << endl;
    cout << "3. Ввод через генерацию данных." << endl;
    cout << "Ваш выбор: "; cin >> choice; // возможен вариант ввода: число целое, вещественное, символы (! + А).
    cout << endl;
    // повторяем ввод, пока не будет достигнут ВОЗМОЖНЫЙ способ ввода матрицы-смежности
    while ((choice != "1") && (choice != "2") && (choice != "3")) // делай пока (НЕ 1-ый) и (НЕ 2-ой) и (НЕ 3-ий) вариант
    {
        cout << "ОШИБКА. Повторите ввод." << endl;
        cout << "1. Ввод с клавиатуры." << endl;
        cout << "2. Ввод из файла." << endl;
        cout << "3. Ввод через генерацию данных." << endl;
        cout << "Ваш выбор: "; cin >> choice; // возможен вариант ввода: число целое, вещественное, символы (! + А).
        cout << endl;
    }
    // используем кейс для ввода матрицы-смежности
    switch (stoi(choice)) // конвертируем строку в целое число.
    {  
    case 1:
    {
        Manual_input(quantity_N, quantity_L, matrices, good_bad); // ввод матрицы-смежности через консольное приложение
        break;
    }
    case 2:
        File_input(quantity_N, quantity_L, matrices, good_bad); // ввод матрицы-смежности с помощью файла
        break;
    case 3:
        Generated_input(quantity_N, quantity_L, matrices, good_bad); // генерация матрицы-смежности
        break;
    }
    if (good_bad == false) // если "не смогли создать матрицу-смежности" - зачем это решать?
    {
        Delete(quantity_N, matrices);
        return 0; // завершаем программу
    }

    cout << endl;
    cout << "----------------------ВЫВОД МАТРИЦЫ СМЕЖНОСТИ---------------------" << endl;

    Confirm_input(quantity_N, quantity_L, matrices);

    cout << endl;
    cout << "-------------------------РЕШЕНИЕ ЗАДАЧИ------------------------------" << endl;

    cout << "1. ВВОД ДАННЫХ О ПЛАТАХ." << endl;
    int quantity_plata;
    cout << "Введите количество плат в схеме: ";
    cin >> quantity_plata;
    while (quantity_plata < 0)
    {
        cout << "ОШИБКА. Повторите ввод." << endl;
        cout << "Введите количество плат в схеме: ";
        cin >> quantity_plata;
    }
    if (((quantity_plata > 0) && (quantity_N == 0)) || ((quantity_plata == 0) && (quantity_N > 0)))
    {
        cout << "Невозможно создать платы." << endl;
        Delete(quantity_N, matrices);
        return 0; // завершаем программу
    }

    cout << endl;
    cout << "----------------------------------------------------------------" << endl;

    vector<int> vertexes; // какие вершины не установлены в схеме - не входят в состав ни одной платы
    for (int i = 0; i < quantity_N; i++)
    {
        vertexes.push_back(i); // закидываем все вершины от 1 до quantity_N или на языке ПК: от 0 до quantity_N - 1
    }
    vector<vector<int>> scheme; // схема в виде матрицы: номер строки - номер платы, а каждая строка содержит элементы вершин (элементов)
    vector<int> plata; // плата, на которую помещаем вершины (текущая рассматриваемая плата)

    int n, l;
    int quantity_n = 0;
    int vertexe; // номер вершины
    int col;
    bool flg;
    auto inter = vertexes.cbegin(); // итератор для удаления вершин
    for (int i = 0; i < quantity_plata; i++)
    {
        cout << "Введите информацию о " << i + 1 << " плате." << endl;
        cout << "Введите количество элементов на плате: ";
        cin >> n;
        while ((n < 0) || (quantity_n + n > quantity_N))
        {
            if (quantity_n + n > quantity_N)
            {
                cout << "ПРЕВЫШЕНО КОЛИЧЕСТВО ВЕРШИН. Повторите ввод." << endl;
                cout << "Введите количество элементов на плате: ";
                cin >> n;
            }
            if (n < 0)
            {
                cout << "ОШИБКА. Повторите ввод." << endl;
                cout << "Введите количество элементов на плате: ";
                cin >> n;
            }

        }
        quantity_n += n;

        cout << "Введите количество выводов на плате: ";
        cin >> l;
        while (l < 0)
        {
            cout << "ОШИБКА. Повторите ввод." << endl;
            cout << "Введите количество выводов на плате: ";
            cin >> l;
        }

        cout << endl;
        cout << "----------------------------------------------------------------" << endl;

        cout << "Введите вершины, которые будут расположены на плате." << endl;
        if (vertexes.size() == 0)
        {
            cout << "Не осталось вершин для выбора." << endl;
        }
        else
        {
            cout << "Оставшиеся вершины: " << vertexes[0] + 1;
            for (int j = 1; j < vertexes.size(); j++)
            {
                cout << ", " << vertexes[j] + 1;
            }
            cout << endl;

            for (int j = 0; j < n; j++)
            {
                cout << "Выберите вершину: ";
                cin >> vertexe;

                flg = false;
                for (int k = 0; k < vertexes.size(); k++)
                {
                    if (vertexe - 1 == vertexes[k])
                    {
                        flg = true;
                    }
                }

                while (flg == false)
                {
                    cout << "ОШИБКА. ДАННАЯ ВЕРШИНА НЕ НАЙДЕНА. Повторите ввод." << endl;
                    cout << "Выберите вершину: ";
                    cin >> vertexe;
                    for (int k = 0; k < vertexes.size(); k++)
                    {
                        if (vertexe - 1 == vertexes[k])
                        {
                            flg = true;
                        }
                    }
                }

                plata.push_back(vertexe - 1);

                while (Quantity_connections(plata, quantity_N, matrices) > l)
                {
                    cout << endl;
                    cout << "ПРЕВЫШЕНО КОЛИЧЕСТВО ВЫВОДОВ. Варианты решения:" << endl;
                    cout << "1. Изменение количества выводов." << endl;
                    cout << "2. Изменение вершины." << endl;
                    cout << "Ваш выбор: "; cin >> choice; // возможен вариант ввода: число целое, вещественное, символы (! + А).
                    cout << endl;
             
                    while ((choice != "1") && (choice != "2")) // делай пока (НЕ 1-ый) и (НЕ 2-ой) вариант
                    {
                        cout << "НЕВЕРНЫЙ ВЫБОР. Повторите ввод." << endl;
                        cout << "1. Изменение количества выводов." << endl;
                        cout << "2. Изменение вершины." << endl;
                        cout << "Ваш выбор: "; cin >> choice; // возможен вариант ввода: число целое, вещественное, символы (! + А).
                        cout << endl;
                    }

                    switch (stoi(choice)) { // конвертируем строку в целое число. 
                    case 1:
                    {
                        cout << "Введите количество выводов на плате: ";
                        cin >> l;
                        while (l < 0)
                        {
                            cout << "ОШИБКА. Повторите ввод." << endl;
                            cout << "Введите количество выводов на плате: ";
                            cin >> l;
                        }
                        break;
                    }
                    case 2:
                    {
                        inter = plata.cbegin();
                        plata.erase(inter + plata.size() - 1); // стираем последний элемент платы
                        cout << "Выберите вершину: ";
                        cin >> vertexe;

                        flg = false;
                        for (int k = 0; k < vertexes.size(); k++)
                        {
                            if (vertexe - 1 == vertexes[k])
                            {
                                flg = true;
                            }
                        }

                        while (flg == false)
                        {
                            cout << "ОШИБКА. ДАННАЯ ВЕРШИНА НЕ НАЙДЕНА. Повторите ввод." << endl;
                            cout << "Выберите вершину: ";
                            cin >> vertexe;
                            for (int k = 0; k < vertexes.size(); k++)
                            {
                                if (vertexe - 1 == vertexes[k])
                                {
                                    flg = true;
                                }
                            }
                        }

                        plata.push_back(vertexe - 1);
                        break;
                    }
                    }
                }
                for (int m = 0; m < vertexes.size(); m++) // ищем индекс добавленной на плату вершины
                {
                    if (vertexe - 1 == vertexes[m])
                    {
                        vertexe = m;
                    }
                }
                inter = vertexes.cbegin();
                vertexes.erase(inter + vertexe);  // и удаляем ее
                cout << endl;
            }

        }
        if ((quantity_n < quantity_N) && (vertexes.size() != 0) && (i == quantity_plata - 1)) // если ты дошел до посл платы и ты что-то на нее установил и при этом остались еще вершины то что-то ты сделал не так
            // n - кол-во эл-в на плате, N - кол-во эл-в на схеме
        {
            for (int j = 0; j < vertexes.size(); j++)
            {
                plata.push_back(vertexes[j]);
                n++;
            }
            cout << "Не достигнуто нужного колиечества вершин. Помещаем оставшиеся вершины в плату." << endl;
            cout << "Новое количество вершин на плате: " << n << endl;
            l = Quantity_connections(plata, quantity_N, matrices);
            cout << "Новое количество выводов: " << l << endl;
        }
        scheme.push_back(plata);
        plata.clear();
    }

    cout << endl;
    cout << "----------------------------------------------------------------" << endl;

    cout << "//----РЕШЕНИЕ ЗАДАЧИ МЕТОДОМ ПАРНЫХ ПЕРЕСТАНОВОК----//" << endl;
    for (int i = 0; i < quantity_plata; i++)
    {
        for (int j = i + 1; j < quantity_plata; j++)
        {
            cout << "Применим метод парных перестановок для платы " << i + 1 << " и для платы " << j + 1 << endl;
            cout << "Количество связей до перемещений: " << Col(scheme[i], scheme[j], quantity_N, matrices) << endl;

            col = 0;
            while ((W(scheme[i], scheme[j], matrices, quantity_N) == false) && (col < 15)) // col - кол-во шагов
            {
                col++;
            }
            cout << "Количество связей после перемещений: " << Col(scheme[i], scheme[j], quantity_N, matrices) << endl;
        }
    }

    cout << endl;
    cout << "-----------------------ВЫВОД ОКОНЧАТЕЛЬНОГО ОТВЕТА--------------------" << endl;

    for (int i = 0; i < scheme.size(); i++)
    {
        cout << "Вершины " << i + 1 << " платы: ";
        cout << scheme[i][0] + 1;
        for (int j = 1; j < scheme[i].size(); j++)
        {
            cout << ", " << scheme[i][j] + 1;
        }
        cout << endl;
    }


    Delete(quantity_N, matrices); // не забываем очищать память!
    return 0; // завершаем программу
}